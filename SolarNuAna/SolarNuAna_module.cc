////////////////////////////////////////////////////////////////////////
// Class:       SolarNuAna
// Module Type: analyzer
// File:        SolarNuAna_module.cc
//
// Generated at Fri Feb  3 15:56:41 2023 by Marco Dias using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art_root_io/TFileDirectory.h"
#include "art_root_io/TFileService.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Hit.h"
#include "TTree.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h" 
#include "larsim/MCCheater/BackTrackerService.h" 

// // DUNETPC specific includes
 #include "nusimdata/SimulationBase/MCTruth.h"
//

//class SolarNuAna;
enum PType{ kUnknown, kMarl, kAPA, kCPA, kAr39, kAr42, kNeut, kKryp, kPlon, kRdon };
class SolarNuAna : public art::EDAnalyzer {
public:
  explicit SolarNuAna(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SolarNuAna(SolarNuAna const &) = delete;
  SolarNuAna(SolarNuAna &&) = delete;
  SolarNuAna & operator = (SolarNuAna const &) = delete;
  SolarNuAna & operator = (SolarNuAna &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

//Selected optional functions
 void beginJob() override;
 void endJob() override;

private:
 void ResetVariables();
 void  FillMyMaps  ( std::map< int, simb::MCParticle> &MyMap, art::FindManyP<simb::MCParticle> Assn, art::ValidHandle< std::vector<simb::MCTruth> > Hand );
 PType WhichParType( int TrID );
 bool  InMyMap     ( int TrID, std::map< int, simb::MCParticle> ParMap );
  // Declare member data here.
  TTree* fHitTree;
  // General event info.
    int Run;
    int SubRun;
    int Event;
  // Truth information about our generated neutrino event
   float NuEnergy;
   float EEnergy;
   float TrueX;
   float TrueY;
   float TrueZ;
 // The reconstructed hits
   int   NTotHits;
  // --- Our fcl parameter labels for the modules that made the data products
  std::string fHitLabel;

  std::string fGEANTLabel;
  std::string fMARLLabel; std::map< int, simb::MCParticle > MarlParts;
  std::string fAPALabel;  std::map< int, simb::MCParticle > APAParts;
  std::string fCPALabel;  std::map< int, simb::MCParticle > CPAParts;
  std::string fAr39Label; std::map< int, simb::MCParticle > Ar39Parts;
  std::string fAr42Label; std::map< int, simb::MCParticle > Ar42Parts;
  std::string fNeutLabel; std::map< int, simb::MCParticle > NeutParts;
  std::string fKrypLabel; std::map< int, simb::MCParticle > KrypParts;
  std::string fPlonLabel; std::map< int, simb::MCParticle > PlonParts;
  std::string fRdonLabel; std::map< int, simb::MCParticle > RdonParts;
  
  int   TotGen_Marl;
  int   TotGen_APA;
  int   TotGen_CPA;
  int   TotGen_Ar39;
  int   TotGen_Neut;
  int   TotGen_Kryp;
  int   TotGen_Plon;
  int   TotGen_Rdon;


  float hitPur,hitCharge;


  
  float nudirx;
  float nudiry;
  float nudirz;
// ******* fcl parameters *******

// --- Declare our services
     art::ServiceHandle<cheat::BackTrackerService> bt_serv;
};


SolarNuAna::SolarNuAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
 fHitLabel      = p.get<std::string> ("HitLabel");
  fGEANTLabel = p.get<std::string> ("GEANT4Label");
  fMARLLabel = p.get<std::string> ("MARLEYLabel");
  fAPALabel  = p.get<std::string> ("APALabel");
  fCPALabel  = p.get<std::string> ("CPALabel");
  fAr39Label = p.get<std::string> ("Argon39Label");
  fAr42Label = p.get<std::string> ("Argon42Label");
  fNeutLabel = p.get<std::string> ("NeutronLabel");
  fKrypLabel = p.get<std::string> ("KryptonLabel");
  fPlonLabel = p.get<std::string> ("PoloniumLabel");
  fRdonLabel = p.get<std::string> ("RadonLabel");
}


void SolarNuAna::ResetVariables()
{
 // Clear my MCParticle maps.
 MarlParts.clear(); APAParts .clear(); CPAParts .clear(); Ar39Parts.clear();
 NeutParts.clear(); KrypParts.clear(); PlonParts.clear(); RdonParts.clear();
 Ar42Parts.clear();
// General event info.
    Run = SubRun = Event = -1;
// Reconstructed hits
   NTotHits  = 0;
 // Set Number of GenParts to 0
   TotGen_Marl = TotGen_APA  = TotGen_CPA  = TotGen_Ar39 = 0;
   TotGen_Neut = TotGen_Kryp = TotGen_Plon = TotGen_Rdon = 0;
}
void SolarNuAna::beginJob()
{
art::ServiceHandle<art::TFileService> tfs;
  fHitTree = tfs->make<TTree>("HitTree","DAQ simulation analysis tree");
  fHitTree->Branch("Event", &Event);
  fHitTree->Branch("SubRun", &SubRun);
  fHitTree->Branch("Run", &Run);
  fHitTree->Branch("hitPur", &hitPur); 
  fHitTree->Branch("hitCharge", &hitCharge);  
}//ResetVariables

void SolarNuAna::analyze(art::Event const & evt)
{
  // Implementation of required member function here.
    // --- We want to reset all of our TTree variables...
    ResetVariables();

     // --- Set all of my general event information...
       Run    = evt.run();
       SubRun = evt.subRun();
       Event  = evt.event();

  NuEnergy = -1;
  EEnergy = -1;
  TrueX = -1e3;
  TrueY = -1e3;
  TrueZ = -1e3;



  // --- Lift out the MARLEY particles.

  // Needed for marley running
  auto MarlTrue = evt.getValidHandle<std::vector<simb::MCTruth> >(fMARLLabel);
  if (MarlTrue->size() != 0){
    if (MarlTrue->at(0).NParticles() > 1){
      const simb::MCParticle& part = MarlTrue->at(0).GetParticle(0);

      NuEnergy = part.E();
      const simb::MCParticle& lep = MarlTrue->at(0).GetParticle(1);
      TrueX = lep.Vx();
      TrueY = lep.Vy();
      TrueZ = lep.Vz();
      EEnergy = lep.E();

      std::cout << "Parts and leps " << part.P() <<"   " << lep.P() << std::endl;
      std::cout << "Parts and leps " << MarlTrue->at(0).NParticles() << std::endl;

      nudirx = part.Px()/part.P();
      nudiry = part.Py()/part.P();
      nudirz = part.Pz()/part.P();

      std::cout << nudirx << "  " << nudiry << "  "<< nudirz << std::endl;
      //std::cout << edirx << "  " << ediry << "  "<< edirz << std::endl;

    }
  }


  // --- Lift out the APA particles.
  auto APATrue = evt.getValidHandle<std::vector<simb::MCTruth> >(fAPALabel);
  art::FindManyP<simb::MCParticle> APAAssn(APATrue,evt,fGEANTLabel);
  FillMyMaps( APAParts, APAAssn, APATrue );
  TotGen_APA = APAParts.size();
  std::cout << "--- The size of APAParts is " << APAParts.size() << std::endl;

  // --- Lift out the CPA particles.
  auto CPATrue = evt.getValidHandle<std::vector<simb::MCTruth> >(fCPALabel);
  art::FindManyP<simb::MCParticle> CPAAssn(CPATrue,evt,fGEANTLabel);
  FillMyMaps( CPAParts, CPAAssn, CPATrue );
  TotGen_CPA = CPAParts.size();
  std::cout << "--- The size of CPAParts is " << CPAParts.size() << std::endl;

  // --- Lift out the Ar39 particles.
  auto Ar39True = evt.getValidHandle<std::vector<simb::MCTruth> >(fAr39Label);
  art::FindManyP<simb::MCParticle> Ar39Assn(Ar39True,evt,fGEANTLabel);
  FillMyMaps( Ar39Parts, Ar39Assn, Ar39True );
  TotGen_Ar39 = Ar39Parts.size();
  std::cout << "--- The size of Ar39Parts is " << Ar39Parts.size() << std::endl;

  // --- Lift out the Ar42 particles.
  auto Ar42True = evt.getValidHandle<std::vector<simb::MCTruth> >(fAr42Label);
  art::FindManyP<simb::MCParticle> Ar42Assn(Ar42True,evt,fGEANTLabel);
  FillMyMaps( Ar42Parts, Ar42Assn, Ar42True );
  //TotGen_Ar42 = Ar42Parts.size();
  std::cout << "--- The size of Ar42Parts is " << Ar42Parts.size() << std::endl;


 art::FindManyP<simb::MCParticle> MarlAssn(MarlTrue,evt,fGEANTLabel);
  FillMyMaps( MarlParts, MarlAssn, MarlTrue );
  TotGen_Marl = MarlParts.size();
  std::cout << "--- The size of MarleyParts is " << MarlParts.size() << std::endl;
  // --- Lift out the reco hits:
   auto reco_hits = evt.getValidHandle<std::vector<recob::Hit> >(fHitLabel);
 // --- Loop over the reconstructed hits to determine the "size" of each hit 
 NTotHits = reco_hits->size();
for(int hit = 0; hit < NTotHits; ++hit) {
    // --- Let access this particular hit.
     recob::Hit const& ThisHit = reco_hits->at(hit);
// --- Lets figure out which particle contributed the most charge to this hit...
   auto const clockData = art::ServiceHandle<detinfo::DetectorClocksService const>()->DataFor(evt);   // NOVO
   int MainTrID    = -1;
   double TopEFrac = -DBL_MAX;
   std::vector< sim::TrackIDE > ThisHitIDE = bt_serv->HitToTrackIDEs(clockData,ThisHit);             // Erro
   for (size_t ideL=0; ideL < ThisHitIDE.size(); ++ideL) {
       if ( ThisHitIDE[ideL].energyFrac > TopEFrac ) {
       	TopEFrac = ThisHitIDE[ideL].energyFrac;
	MainTrID = ThisHitIDE[ideL].trackID;
        }
         }
    // --- Lets figure out how that particle was generated...
   PType ThisPType = WhichParType( MainTrID );
    // --- I want to fill a vector of coll plane hits, for each of the different kinds of generator.
 if (ThisHit.View() == 2) 
{
    hitPur = ThisPType== 1 ? 1 : 0; // marley
     if(hitPur==0) continue;
      const std::vector<int> trks = bt_serv->HitToTrackIds(clockData,ThisHit);     // Erro
      if (trks.size()==0) continue;
      fHitTree->Fill();
}
}//Loop over reco_hits
}
//......................................................
void SolarNuAna::FillMyMaps( std::map< int, simb::MCParticle> &MyMap, art::FindManyP<simb::MCParticle> Assn, art::ValidHandle< std::vector<simb::MCTruth> > Hand )
{
for ( size_t L1=0; L1 < Hand->size(); ++L1 ) {
 for ( size_t L2=0; L2 < Assn.at(L1).size(); ++L2 ) {
  const simb::MCParticle ThisPar = (*Assn.at(L1).at(L2));
   MyMap[ThisPar.TrackId()] = ThisPar;          }
      }
    return;
                          }
//......................................................
PType SolarNuAna::WhichParType( int TrID )
{
  // Check if Ar42
  if ( InMyMap( TrID, Ar42Parts ) ) {
  return kAr42;
   }
  else if ( InMyMap( TrID, Ar39Parts ) ) {
 return kAr39;
  // Check if MARLEY
   } else  if ( InMyMap( TrID, MarlParts ) ) {
  return kMarl;
  // Check if APA
   } else if ( InMyMap( TrID, APAParts  ) ) {
   return kAPA;
 // Check if CPA
   } else if ( InMyMap( TrID, CPAParts  ) ) {
   return kCPA;
   // Check if Neut
  } else if ( InMyMap( TrID, NeutParts ) ) {
   return kNeut;
   // Check if Kryp
  } else if ( InMyMap( TrID, KrypParts ) ) {
   return kKryp;
  // Check if Plon
  } else if ( InMyMap( TrID, PlonParts ) ) {
  return kPlon;
  // Check if Rdon
  } else if ( InMyMap( TrID, RdonParts ) ) {
  return kRdon;
  }
  // If get this far then who knows???
  return kUnknown;
  }

//......................................................
bool SolarNuAna::InMyMap( int TrID, std::map< int, simb::MCParticle> ParMap )
{
  std::map<int, simb::MCParticle>::iterator ParIt;
    ParIt = ParMap.find( TrID );
    if ( ParIt != ParMap.end() ) {
   //std::cout << "In Map " << (ParMap.at(TrID)).second->TrackID() << "  " << (ParMap.at(TrID)).second->PdgCode() < std::endl;
    return true;
    } else
    return false;
}
 //......................................................

void SolarNuAna::endJob()
{
mf::LogVerbatim("SolarNuAna") << "SolarNuAna finished job";
} 
DEFINE_ART_MODULE(SolarNuAna)
